# JS作用域

## 函数作用域

用函数形式以`function(){……}`类似的代码包起来的（省略号`……`）区域，即**函数作用域**

```js
var a = "coffe";//在全局作用域
function func(){//作用域A
    var b = "coffe";

    function func1(){//作用域B。定义一个函数，把不想公开的内容隐藏起来
        var b = "1891";//这里的a把外层的a的值覆盖了
        var c = "b";
        //这里可以放有很多其他要对外隐藏的内容：变量或者函数
        console.log(b);//>> 1891
    }

    console.log(b);//>> coffe
    console.log(c);//>> Uncaught ReferenceError: b is not defined
    func1();//>> 1891
}

console.log(a);//>> coffe
console.log(b);//>> Uncaught ReferenceError: b is not defined
// JS引擎会先从离自己最近的作用域A查找变量a，找到就不再继续查找
// 找不到就去上层作用域（此例中上层作用域是全局作用域）继续查找
```

用一个IIFE加匿名函数的写法，把变量隐藏起来，函数外面就没法访问它，函数内部可以访问到它

```js
//全局作用域

function func(){//作用域A
    var a = "coffe";

    (function(){//作用域B。一个IIFE形式的函数，把不想公开的内容隐藏起来
        var a = "1891";

        //这里可以放有很多其他要对外隐藏的内容：变量或者函数

        console.log(a);//>> 1891
    })();
}
```

## 块级作用域

ES6规定，在某个花括号对`{ }`的内部**用**`let`**关键字生声明的变量和函数拥有块级作用域**

**块级作用域和函数作用域也可以统称为局部作用域**。

出于向后（backward）兼容的考虑，在块级作用域中声明的函数依然可以在作用域外部引用。
**如果需要函数只在块级作用域中起作用，应该用let关键字写成函数表达式**，而不是函数声明语句。 
**使用var定义的函数也会能够在块级作用域外被访问**，所以你希望程序的作用域正常，请使用let或const！

```js
{
  function func(){//函数声明
    return 1;
  }
}

//或者

{
  var func = function (){//未使用let关键字的函数表达式
    return 1;
  }
}

console.log(func());//>> 1 仍然能访问
```

### 声明提前

- var声明的变量有副作用：**声明提前**
- `var`声明变量有污染。循环里面的i在循环完毕后就没有用了，但并没有被回收掉，而是一直存在的“垃圾”变量，污染了当前的环境。而用`let`声明变量，事后这种垃圾变量会很快被回收掉。

### 暂时性死区

使用let或const定义的变量如果在声明前使用，会报错。这种现象叫做暂时性死区

## 作用域链

多个作用域对应的变量对象串联起来组成的链表就是作用域链，**这个链表是以引用的形式保持对变量对象的访问**。

作用域链保证了当前执行上下文对符合访问权限的变量和函数的有序访问。

查找变量/函数时JS引擎是从里离它最近作用域开始的查找的，也即从离它最近的变量对象（VO）开始查找。

如果在当前的变量对象里面找不到目标变量/函数，就在上一级作用域的变量对象里面查找