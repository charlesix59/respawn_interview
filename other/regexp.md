# 正则表达式

> 如果你希望了解js的RegExp对象，可以查阅第一章第二节-对象。

## 什么是正则表达式

正则表达式是用于匹配字符串中字符组合的模式

实现正则表达式的算法叫做正则表达式引擎，它一般有两种实现方式：
DFA自动机（Deterministic Finite Automata，确定的有穷自动机）和
NFA自动机（Non deterministic Finite Automata，不确定的有穷自动机）。

## 写一个正则表达式

一个正则表达式模式是由简单的字符所构成的，比如 /abc/；
或者是简单和特殊字符的组合，比如 /ab*c/ 或 /Chapter (\d+)\.\d*/

**简单模式**是由你想直接找到的字符构成

当你需要匹配一个不确定的字符串时，比如寻找一个或多个 "b"，或者寻找空格，可以在模式中使用**特殊字符**。

### 特殊字符表

| 字符             | 含义                                                                                                                                                                                                                                                                                                                                                                                                  |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `\(单个下划线打不出来)` | 1. 在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。<br/>2. 在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解                                                                                                                                                                                                                                                                                                                      |
| `^`            | 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。                                                                                                                                                                                                                                                                                                                                                             |
| `$`            | 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置                                                                                                                                                                                                                                                                                                                                                                |
| `*`            | 匹配前一个表达式 0 次或多次。等价于 `{0,}`                                                                                                                                                                                                                                                                                                                                                                          |
| `+`            | 匹配前面一个表达式 1 次或者多次。等价于 `{1,}`。                                                                                                                                                                                                                                                                                                                                                                       |
| `?`            | 匹配前面一个表达式 0 次或者 1 次。等价于 `{0,1}`。如果**紧跟在任何量词 *、 +、? 或 {} 的后面**，将会使量词变为**非贪婪**（匹配尽量少的字符），和缺省使用的**贪婪模式**（匹配尽可能多的字符）正好相反                                                                                                                                                                                                                                                                                |
| `.`            | （小数点）默认匹配除换行符之外的任何单个字符。如果 `s` ("dotAll") 标志位被设为 true，它也会匹配换行符。                                                                                                                                                                                                                                                                                                                                      |
| `(x)`          | 它会匹配 'x' 并且记住匹配项。其中括号被称为*捕获括号*。`$&` 表示整个用于匹配的原字符串。                                                                                                                                                                                                                                                                                                                                                  |
| `(?:x)`        | 匹配 'x' 但是不记住匹配项。这种括号叫作*非捕获括号*，使得你能够定义与正则表达式运算符一起使用的子表达式                                                                                                                                                                                                                                                                                                                                             |
| `x(?=y)`       | 匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。但是y不是匹配的一部分                                                                                                                                                                                                                                                                                                                                                             |
| `(?<=y)`       | 匹配'x'仅当'x'前面是'y'.这种叫做后行断言。但是y不是匹配的一部分                                                                                                                                                                                                                                                                                                                                                               |
| `x(?!y)`       | 仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找。                                                                                                                                                                                                                                                                                                                                                                    |
| `(?<!*y*)*x*`  | 仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找。                                                                                                                                                                                                                                                                                                                                                                     |
| `x\|y`         | 匹配‘x’或者‘y’。                                                                                                                                                                                                                                                                                                                                                                                         |
| `{n}`          | n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。<br>                                                                                                                                                                                                                                                                                                                                                                    |
| `{n,}`         | n 是一个正整数，匹配前一个字符至少出现了 n 次。                                                                                                                                                                                                                                                                                                                                                                          |
| `{n,m}`        | n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。                                                                                                                                                                                                                                                                                                                                                                    |
| `[xyz]`        | 一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。<br>                                                                                                                                                                                                                                                                                           |
| `[^xyz]`       | 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。                                                                                                                                                                                                                                                                                                                               |
| `[\b]`         | 匹配一个退格 (U+0008)。（不要和\b混淆了。）                                                                                                                                                                                                                                                                                                                                                                         |
| `\b`           | 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是 0。（不要和 [\b] 混淆了）<br/>/\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。<br><br>**备注：** JavaScript 的正则表达式引擎将[特定的字符集](https://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6)定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。 |
| `\B`           | 匹配一个非单词边界。匹配如下几种情况：<br><br>- 字符串第一个字符为非“字”字符<br>- 字符串最后一个字符为非“字”字符<br>- 两个单词字符之间<br>- 两个非单词字符之间<br>- 空字符串<br><br>                                                                                                                                                                                                                                                                                   |
| `\c*X*`        | 当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。                                                                                                                                                                                                                                                                                                                                                                |
| `\d`           | 匹配一个数字`。``等价于 [0-9]`。                                                                                                                                                                                                                                                                                                                                                                               |
| `\D`           | 匹配一个非数字字符`。``等价于 [^0-9]`。                                                                                                                                                                                                                                                                                                                                                                           |
| `\f`           | 匹配一个换页符 (U+000C)。                                                                                                                                                                                                                                                                                                                                                                                   |
| `\n`           | 匹配一个换行符 (U+000A)。                                                                                                                                                                                                                                                                                                                                                                                   |
| `\r`           | 匹配一个回车符 (U+000D)。                                                                                                                                                                                                                                                                                                                                                                                   |
| `\s`           | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于 `[\f\n\r\t\v\u0020\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`                                                                                                                                                                                                                                                                               |
| `\S`           | 匹配一个非空白字符。等价于 `[^\f\n\r\t\v\u0020\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`                                                                                                                                                                                                                                                                                              |
| `\t`           | 匹配一个水平制表符 (U+0009)。                                                                                                                                                                                                                                                                                                                                                                                 |
| `\v`           | 匹配一个垂直制表符 (U+000B)。                                                                                                                                                                                                                                                                                                                                                                                 |
| `\w`           | 匹配一个单字字符（字母、数字或者下划线）。等价于 `[A-Za-z0-9_]`。                                                                                                                                                                                                                                                                                                                                                            |
| `\W`           | 匹配一个非单字字符。等价于 `[^A-Za-z0-9_]`。                                                                                                                                                                                                                                                                                                                                                                      |
| `\*n*`         | 在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。                                                                                                                                                                                                                                                                                                                                                        |
| `\0`           | 匹配 NULL（U+0000）字符，不要在这后面跟其他小数，因为 `\0<digits>` 是一个八进制转义序列。                                                                                                                                                                                                                                                                                                                                           |
| `\xhh`         | 匹配一个两位十六进制数（\x00-\xFF）表示的字符。                                                                                                                                                                                                                                                                                                                                                                        |
| `\uhhhh`       | 匹配一个四位十六进制数表示的 UTF-16 代码单元。                                                                                                                                                                                                                                                                                                                                                                         |
| \u{hhhh}       | （仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。                                                                                                                                                                                                                                                                                                                                                               |

## 正则表达式运行原理

> 摘自前端内参

### 第1步. 编译

当我们用字面量或者RegExp构造函数的方式创建一个正则表达式对象，引擎会验证它是否合法，若是，则根据它的内容生成一段计算机可直接执行的机器语言程序，以便后面执行匹配的任务。
提示：
如果把正则表达式对象赋值给一个变量，就不用反复地执行编译过程了。所以一个好的习惯是，用一个变量存储正则表达式对象。

### 第2步. 找到「开始位置」

当正则表达式进入使用状态，首先就要确定从目标字符串的哪个位置开始搜索。
开始位置一般在目标字符串最开头字符的位置，或者由正则表达式的lastIndex属性指定。
lastIndex：
当正则表达式带有/g这个flags的时候，正则表达式的lastIndex属性只作为exec和test方法的起始搜索位置。当flags非/g或任何正则表达式作为参数传递给字符串的match、replace、search以及split方法时，会从目标字符串开头字符的位置搜索。
当（因为匹配失败）执行完第4步，然后返回到第2步这里的时候，开始位置则**在最后一次匹配位置的下一个位置上。**
开始位置即可在最后一次匹配位置之后，也可以在其之前，“下一个位置”并不意味着一定在“最后一次匹配位置”之后。

### 第3步. 匹配每个元规则

一旦开始位置确定好，引擎会解析出正则表达式可能包含的元规则（无法再分解的最小的匹配规则），然后将正则表达式的元规则逐个地和目标字符串进行匹配，匹配成功引擎则会“吃掉”匹配的字符串，针然后对剩余的字符串做匹配。
提示：
为方便读者理解，可以把正则表达式引擎想象成一条贪吃蛇，我们用「吃掉」、「吐出」之类的词来分别形象地描述「匹配成功」后、「匹配失败」后引擎所做的操作。
当正则表达式有多个分支（通常是符号|，也属于元规则）的情况，若一个特定的分支匹配失败的时候，引擎会吐出该分支已匹配的字符串，此时引擎在目标字符串的搜索位置，会重新返回到之前尝试匹配分支的位置上，然后，引擎再尝试匹配其它分支。

### 第4步. 匹配结果

结果为「完全匹配」或者「彻底匹配失败」。
如果在字符串当前的位置发现了一个完全匹配（匹配整个正则表达式），那么引擎会返回完全匹配的结果；
反之，如果引擎尝试了所有可能的分支都没有匹配到，引擎会回退到第2步，然后从下一个字符重新开始尝试；
当字符串的每个字符都经历了上面的第2、第3步，若仍没有完全匹配的话，那引擎会返回彻底匹配失败的结果。

## 正则表达式优化

### 合理分配贪婪模式与懒惰模式

下面这段代码演示了带有量词时的回溯过程。

> **常用量词有以下：** `*` 任意多个； `+` 至少1个； `?` 0或1个； `{m,n}` m到n个。

```js
(function () {
    var aLongString = "<div>《前端内参—挑战Hard模式下的前端面试之旅》</div>" +
        "<small>帮助前端工程师们夯实技术以通过一线互联网企业面试。</small>" +
        "A book that tell you how to get the <strong>hard-mode</strong>" +
        "<small> interview of Front-End done</small>";
    //定义一个正则表达式对象
    var re = RegExp(/<div>.*<\/div>/, "i");
    //返回一个结果数组
    var result = re.exec(aLongString);
    //输出匹配的结果
    console.log(result[0]);//>> <div>《前端内参—挑战Hard模式下的前端面试之旅》</div>
})();
```

上面代码的正则表达式带有贪婪量词`*`，表示尽可能多的匹配。代码执行后，输出了`aLongString`字符串开头的第一行。下面详细分析一下匹配的过程：

① 引擎开始搜索时，会从字符串开始位置查找`<div>`，很快就匹配到了，引擎吃掉目标字符串的前5个字符`<div>`；

② 接着，引擎要匹配正则表达式里面的`.*`，`.`代表除行终止符（\n，\r，\u2028，\u2029）以外的任意字符，`*`
是贪婪量词，匹配0次或多次，并尽可能多的匹配，因此引擎会吃掉`aLongString`的全部剩余字符。

③ 然后，引擎要匹配正则表达式里的`<`
，此时aLongString结尾已经没有字符可以与之匹配，故匹配失败，发生回溯，引擎吐出1个字符，尝试继续匹配正则表达式里的`<`
，（如此尝试了7次之后）直到回溯到`</small>`中的首字符`<`，匹配成功。

④ 接下来，要匹配正则表达式里面的`\/`，很明显匹配成功，`</small>`中的`</`均被引擎吃掉。

⑤ 接着，匹配正则表达式里的`d`，而目标字符串提供的是`s`，所以匹配失败，引擎继续回溯，吐出1个之前吃掉的字符；

⑥ 然后执行之前③~⑤，（重复110多次）直到最后匹配`aLongString`字符串第一行末尾的`</div>`；

⑦ 终于，整个正则表达式匹配成功，引擎返回结果。

> **小知识：贪婪模式、懒惰模式、独占模式** 正则表达式默认采用的是贪婪模式，表示尽可能多地匹配。
> 在量词后面直接加上一个问号`?`就是懒惰模式了，表示尽可能少地匹配。
> 在量词后面直接加上一个加号`+`就是独占模式了，表示尽可能多地匹配，但是不回溯。
> JavaScript不支持独占模式。

上面贪婪模式的代码，回溯的次数就超级多了，会造成大量的计算浪费，因此可以改成懒惰模式，减少回溯的次数。如下代码：

```js
(function () {
    var aLongString = "<div>《前端内参—挑战Hard模式下的前端面试之旅》</div>" +
        "<small>帮助前端工程师们夯实技术以通过一线互联网企业面试。</small>" +
        "A book that tell you how to get the <strong>hard-mode</strong>" +
        "<small> interview of Front-End done</small>";
    //注意.*? 仅仅多了一个?号，就变成了懒惰模式，减少了回溯的次数
    var re = RegExp(/<div>.*?<\/div>/, "i");
    var result = re.exec(aLongString);
    console.log(result[0]);//>> <div>《前端内参—挑战Hard模式下的前端面试之旅》</div>
})();
```

上面的代码，懒惰模式的`*?`表示尽可能少的匹配，匹配失败也会回溯，只是回溯的方向与贪婪模式下恰好相反：
贪婪模式会从字符串末尾往开头的方向回溯，懒惰模式从字符串开头往末尾的方向回溯。具体分析如下：

① 引擎开始搜索时，会从字符串开始位置查找`<div>`，很快就匹配到了字符串的前5个字符`<div>`；

② 接着，要匹配正则表达式里面的`.*?`，`*`表示匹配0次和多次，`?`表示处于懒惰模式下，会尽可能少的匹配，也即从0次开始匹配，匹配成功；

③ 然后，要匹配正则表达式里的`<`，字符串里面提供的字符是`《`，匹配失败，回溯，正则表达式里的`*`尝试匹配1次。

④ 下一个开始位置是`《`右边的`前`，引擎从这里个位置开始搜索，同上，正则表达式里面的`<`与字符串里面的`前`
会匹配失败，回溯，正则表达式里的`*`尝试匹配2次。
如此回溯23次，直到搜索到字符串`aLongString`第一行末尾的`</div>`，匹配成功。

上面的例子，懒惰模式的回溯次数会少很多，可以数得出来是23次，比贪婪模式下的110多次回溯少了太多。

### 正则表达式的优化方法

#### 1.消除量词嵌套

对于量词嵌套的情况，可以用一些优化消除嵌套，如下所示：

```js
var re0 = /(a+)+b/;
//可以优化为
var re1 = /a+b/;

var re2 = /(a*)*/;
//可以优化为
var re3 = /a*/;
```

这样嵌套量词变成不嵌套的形式后，运算量会大大减少，正则表达式运行效率会极大地提升。

#### 2.使用合适的量词

合理使用量词，合理使用贪婪模式或懒惰模式

#### 3.将简单必须的字符放在开头

正则表达式的第一个字符应该尽可能快速地排除明显不匹配的位置。
比如将锚点（匹配一个位置，^和$、\b等）、字符字面量（匹配具体字符，包括需要转义和不需要转义的）
、字符组（比如[a-z]、[A-Z]）放在正则表达式的开头是比较好的。

另外避免以分组和分支结构开头，比如避免使用(abc*)或a|b|c这种结构开头，
因为它们会强迫正则表达式识别目标字符串中的多种起始字符，造成大量运算。

#### 4.避免重复编译

前面讲运行原理的时候提到过，把正则表达式赋值给变量以避免对它们重新编译。最主要的是避免在循环体内反复编译正则表达式，

#### 5.简化

避免写复杂的正则表达式，也要避免用正则表达式处理复杂的搜索任务。将复杂的正则表达式拆分成多个简单的子正则表达式，
让每个子正则表达式在前一个子正则表达式匹配的结果中继续搜索，这样做会更加容易满足需求，而且通常也会有更高的运行效率。

## 常用正则表达式

1. 匹配 16 进制颜色值
    ```js
    var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;
   ```
2. 匹配日期，如 yyyy-mm-dd 格式
    ```js
    var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
    ```
3. 匹配 qq 号
    ```js
    var regex = /^[1-9][0-9]{4,10}$/g;
    ```
4. 手机号码
    ```js
    var regex = /^1[34578]\d{9}$/g;
    ```
5. 用户名
    ```js
    var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$/;
    ```
6. 校验密码强度

   密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。
   ```js
   var regexp = /^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$/;
   ```
7. 检验中文
   ```js
   var regexp = /^[\\u4e00-\\u9fa5]{0,}$/
   ```
8. 邮箱
   ```js
   var regexp = /^([A-Za-z0-9_-.])+@([A-Za-z0-9_-.])+.([A-Za-z]{2,4})$/
   ```
9. ipv4
   ```js
   var regexp = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
   ```
10. 车牌号
   ```js
    var regexp = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/
   ```
11. url
   ```js
   var regexp = /^((https?|ftp|file)://)?([da-z.-]+).([a-z.]{2,6})([/w .-]*)*/?$/
   ```

